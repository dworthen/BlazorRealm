<!DOCTYPE html>
<!--[if IE]><![endif]-->
<html>
  
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
    <title>Blazor Realm | Blazor Realm </title>
    <meta name="viewport" content="width=device-width">
    <meta name="title" content="Blazor Realm | Blazor Realm ">
    <meta name="generator" content="docfx 2.36.2.0"> 
    <link rel="shortcut icon" href="../favicon.ico">
    <link rel="stylesheet" href="../styles/docfx.vendor.css">
    <link rel="stylesheet" href="../styles/docfx.css">
    <link rel="stylesheet" href="../styles/hljs-vs.css"> 
    <link rel="stylesheet" href="../styles/main.css">
    <meta property="docfx:navrel" content="../toc.html">
    <meta property="docfx:tocrel" content="toc.html">   
    <meta property="docfx:newtab" content="true">
  </head>  <body data-spy="scroll" data-target="#affix" data-offset="120">
    <div id="wrapper">
      <header>
        
        <nav id="autocollapse" class="navbar navbar-inverse ng-scope" role="navigation">
          <div class="container">
            <div class="navbar-header">
              <button type="button" class="navbar-toggle" data-toggle="collapse" data-target="#navbar">
                <span class="sr-only">Toggle navigation</span>
                <span class="icon-bar"></span>
                <span class="icon-bar"></span>
                <span class="icon-bar"></span>
              </button>
              
        <a class="navbar-brand" href="../index.html">
            Realm
        </a>
            </div>
            <div class="collapse navbar-collapse" id="navbar">
              <form class="navbar-form navbar-right" role="search" id="search">
                <div class="form-group">
                  <input type="text" class="form-control" id="search-query" placeholder="Search" autocomplete="off">
                </div>
              </form>
            </div>
          </div>
        </nav>
        
        <div class="subnav navbar navbar-default">
          <div class="container hide-when-search" id="breadcrumb">
            <ul class="breadcrumb">
              <li></li>
            </ul>
          </div>
        </div>
      </header>
      <div role="main" class="container body-content hide-when-search">
        
        <div class="sidenav hide-when-search">
          <a class="btn toc-toggle collapse" data-toggle="collapse" href="#sidetoggle" aria-expanded="false" aria-controls="sidetoggle">Show / Hide Table of Contents</a>
          <div class="sidetoggle collapse" id="sidetoggle">
            <div id="sidetoc"></div>
          </div>
        </div>
        <div class="article row grid-right">
          <div class="col-md-10">
            <article class="content wrap" id="_content" data-uid="">
<h1 id="blazor-realm">Blazor Realm</h1>

<p><a href="https://redux.js.org/">Redux</a> state management for <a href="https://dotnet.microsoft.com/apps/aspnet/web-apps/blazor">Blazor.net</a>.</p>
<h1 id="getting-started">Getting Started</h1>
<ol>
<li>For getting started with Blazor, visit <a href="https://docs.microsoft.com/en-us/aspnet/core/blazor/get-started?view=aspnetcore-3.1&amp;tabs=visual-studio">https://docs.microsoft.com/en-us/aspnet/core/blazor/get-started?view=aspnetcore-3.1&tabs=visual-studio</a>.</li>
<li>Install <a href="https://www.nuget.org/packages/Blazor.Realm/">https://www.nuget.org/packages/Blazor.Realm/</a>.</li>
</ol>
<h1 id="application-state">Application State</h1>
<pre><code class="lang-csharp">// AppState.cs
public class AppState
{
    public int Count { get; set; } = 0;
    public IEnumerable&lt;WeatherForecast&gt; WeatherForecasts { get; set; } = new WeatherForecast[] { };
}

public class WeatherForecast
{
    public DateTime Date { get; set; }
    public int TemperatureC { get; set; }
    public int TemperatureF { get; set; }
    public string Summary { get; set; }
}
</code></pre><h1 id="actions">Actions</h1>
<pre><code class="lang-csharp">//Actions.cs

// Counter Actions
public class IncrementByOne : IRealmAction { }

public class IncrementByValue : IRealmAction
{
    public int Value { get; set; }
    public IncrementByValue(int value)
    {
        Value = value;
    }
}

public class DecrementByOne : IRealmAction { }

public class DecrementByValue : IRealmAction
{
    public int Value { get; set; }
    public DecrementByValue(int value)
    {
        Value = value;
    }
}

public class ResetCount : IRealmAction { }

// WeatherForecasts Actions
public class ClearWeatherForecasts : IRealmAction { }

public class SetWeatherForecasts : IRealmAction
{
    public IEnumerable&lt;WeatherForecast&gt; WeatherForecasts { get; set; }
    public SetWeatherForecasts(IEnumerable&lt;WeatherForecast&gt; forecasts)
    {
        WeatherForecasts = forecasts;
    }
}
</code></pre><p>Actions must implement <code>IRealmAction</code>.</p>
<h1 id="reducer">Reducer</h1>
<pre><code class="lang-csharp">// Reducer.cs

public static class Reducers
{
    public static AppState RootReducer(AppState appState, IRealmAction action)
    {
        if(appState == null)
        {
            throw new ArgumentNullException(nameof(appState));
        }

        // Return a new AppState
        return new AppState
        {
            // Composing Reducers for components
            Count = CounterReducer(appState.Count, action),
            WeatherForecasts = WeatherForecastsReducer(appState.WeatherForecasts, action)
        };
    }

    public static int CounterReducer(int count, IRealmAction action)
    {
        switch(action)
        {
            case IncrementByOne _:
                return count + 1;
            case IncrementByValue a:
                return count + a.Value;
            case DecrementByOne _:
                return count - 1;
            case DecrementByValue a:
                return count - a.Value;
            case ResetCount _:
                return 0;
            default:
                return count;
        }
    }

    public static IEnumerable&lt;WeatherForecast&gt;
    WeatherForecastsReducer(IEnumerable&lt;WeatherForecast&gt; forecasts, IRealmAction action)
    {
        switch(action)
        {
            case ClearWeatherForecasts _:
                return new WeatherForecast[] { };
            case SetWeatherForecasts a:
                return a.WeatherForecasts;
            default:
                return forecasts;
        }
    }

}
</code></pre><h1 id="add-realm-service">Add Realm Service</h1>
<p>Register the Realm store service in the Startup.cs <code>ConfigureServices</code> method.</p>
<pre><code class="lang-csharp">// Startup.cs
public void ConfigureServices(IServiceCollection services)
{
    ...
    services.AddRealmStore&lt;AppState&gt;(new AppState(), Reducers.RootReducer);
}
</code></pre><h1 id="components">Components</h1>
<p>There are two ways to work with a Realm store within a Blazor component.</p>
<ol>
<li>State components</li>
<li>RealmComponent Inheritance</li>
</ol>
<blockquote><p><strong>Note</strong></p>
<p>Don&#39;t forget to add <code>@using Blazor.Realm</code> to the top of Razor components or to the _imports.razor file.</p>
</blockquote>
<h2 id="state-component">State Component</h2>
<p>The <code>RealmStateContainer</code> component is akin to the render prop technique common in React components. Like the render prop technique, <code>RealmStateContainer</code></p>
<ol>
<li>Follows a component model for working with and injecting state into child components.</li>
<li>Will render the <code>ComponentTemplate</code> instead of implementing/rendering its own logic.</li>
</ol>
<p><code>RealmStateContainer</code> will dynamically render the <code>ComponentTemplate</code> and inject the <code>AppState</code> that was registered in Startup.cs <code>ConfigureServices</code>.</p>
<p>Here is an example.</p>
<pre><code class="lang-csharp">@page &quot;/counter&quot;
@addTagHelper *, Blazor.Realm
@using Blazor.Realm;

&lt;RealmStateContainer TState=&quot;AppState&quot; Context=&quot;store&quot;&gt;
    &lt;ComponentTemplate&gt;
        @{
            AppState State = store.GetState();
            Action&lt;IRealmAction&gt; Dispatch = store.Dispatch;

            Action IncrementCount = () =&gt; Dispatch(new IncrementByValue(ChangeAmount));
            Action DecrementCount = () =&gt; Dispatch(new DecrementByValue(ChangeAmount));
        }
        &lt;h1&gt;Counter&lt;/h1&gt;

        &lt;p&gt;Current count: @State.Count&lt;/p&gt;

        Change By: &lt;input type=&quot;text&quot; name=&quot;IncementAmount&quot; bind=&quot;@ChangeAmount&quot; /&gt;&lt;br /&gt;

        &lt;button class=&quot;btn btn-primary&quot; onclick=&quot;@IncrementCount&quot;&gt;Increment&lt;/button&gt;&lt;br /&gt;
        &lt;button class=&quot;btn btn-primary&quot; onclick=&quot;@DecrementCount&quot;&gt;Decrement&lt;/button&gt;&lt;br /&gt;
    &lt;/ComponentTemplate&gt;
&lt;/RealmStateContainer&gt;

@code {
    private int ChangeAmount { get; set; } = 1;
}
</code></pre><ul>
<li><code>TState</code> attribute specifies the type of the Realm Store to inject. This type should match what was registered in the Startup.cs <code>ConfigureServices</code> method.</li>
<li><code>Context</code> attribute defines the variable name used for exposing the Realm store to the <code>ComponentTemplate</code>.</li>
<li><code>ComponentTemplate</code> specify what to render and has access to the Realm store captured in the context variable that was injected by <code>RealmStateContainer</code>.</li>
</ul>
<p>Here is another example: <a href="https://github.com/dworthen/BlazorRealm/blob/master/examples/BlazorClientApp/Pages/FetchData.razor">https://github.com/dworthen/BlazorRealm/blob/master/examples/BlazorClientApp/Pages/FetchData.razor</a></p>
<p>Notice that this example does not render content directly. Instead the <code>ComponentTemplate</code> renders a custom <code>WeatherForecastsTemplate</code> component, setting all necessary props (<a href="https://github.com/dworthen/BlazorRealm/blob/master/examples/BlazorClientApp/Pages/FetchData.razor#L16">https://github.com/dworthen/BlazorRealm/blob/master/examples/BlazorClientApp/Pages/FetchData.razor#L16</a>). This is similar to defining pure UI components in React as functional components and then wrapping those components in Class components for managing and injecting state. That way, the pure components stay pure and reusable.</p>
<h2 id="realmcomponent-inheritance">RealmComponent Inheritance</h2>
<p>The second option for working with a Realm store it to inherit from <code>RealmComponent&lt;TState&gt;</code>. This will expose</p>
<ol>
<li>The application state as <code>State</code>.</li>
<li>A <code>Dispatch</code> action.</li>
</ol>
<pre><code class="lang-csharp">// Counter.razor
@page &quot;/counter&quot;
@inherits RealmComponent&lt;AppState&gt;

&lt;CounterTemplate Count=@State.Count ChangeAmount=1 OnIncrement=@Increment OnDecrement=@Decrement&gt;

@code {
    void Increment()
    {
        Dispatch(new Redux.Actions.Counter.IncrementByValue(ChangeAmount));
    }

    void Decrement()
    {
        Dispatch(new Redux.Actions.Counter.DecrementByValue(ChangeAmount));
    }
}

// CounterTemplate.razor
&lt;h1&gt;Counter&lt;/h1&gt;

&lt;p&gt;Current count: @Count&lt;/p&gt;

Change By: &lt;input type=&quot;text&quot; bind=&quot;@ChangeAmount&quot; /&gt;&lt;br /&gt;

&lt;button class=&quot;btn btn-primary&quot; onclick=&quot;@OnIncrement&quot;&gt;Increment&lt;/button&gt;&lt;br /&gt;
&lt;button class=&quot;btn btn-primary&quot; onclick=&quot;@OnDecrement&quot;&gt;Decrement&lt;/button&gt;&lt;br /&gt;

@code {
  [Parameter] public int Count { get; set; } = 0;
  [Parameter] public int ChangeAmount { get; set; } = 1;
  [Parameter] public Action OnIncrement { get; set; }
  [Parameter] public Action OnDecrement { get; set; }
}
</code></pre><p>The above example uses two components. <code>Counter</code> inherits from <code>RealmComponent</code> and is thus coupled to the store/data source. <code>CounterTemplate</code>, on the other hand, is a pure component receiving all data as props and therefore more reusable. This is similar to defining pure UI components in React as functional components and then wrapping those components in Class components for managing and injecting state.</p>
<h1 id="async-actions">Async Actions</h1>
<p>As with Redux, Async actions in Realm are handled by middleware.</p>
<ol>
<li>Download the <a href="https://www.nuget.org/packages/Blazor.Realm.Async/">Blazor.Realm.Async nuget package</a>.</li>
<li>Add Async actions, this time implementing <code>IAsyncRealmAction</code>.</li>
</ol>
<pre><code class="lang-csharp">// Actions.cs

public class AsyncIncrementCounter : IAsyncRealmAction
{
    public Store&lt;AppState&gt; Store { get; set; }
    public int IncrementAmount { get; set; }
    public AsyncIncrementCounter(Store&lt;AppState&gt; store, int incrementAmount = 1)
    {
        Store = store ?? throw new ArgumentNullException(nameof(store));
        IncrementAmount = incrementAmount;
    }

    public async Task Invoke()
    {
        // Dispatch events to handle the start, middle
        // and end of async actions.
        // StartLoading and Endloading
        // are normal, sync actions defined in Actions.cs
        Store.Dispatch(new StartLoading());
        // Something async, like network call
        await Task.Delay(3000);
        // Call sync action to increment Counter
        Store.Dispatch(new IncrementByValue(IncrementAmount));
        Store.Dispatch(new EndLoading());
    }
}
</code></pre><h2 id="register-async-middleware">Register Async Middleware</h2>
<pre><code class="lang-csharp">// Startup.cs
public void Configure(IBlazorApplicationBuilder app,
    IStoreBuilder&lt;AppState&gt; RealmStoreBuilder)
{
    RealmStoreBuilder.UseRealmAsync&lt;AppState&gt;();

    app.AddComponent&lt;App&gt;(&quot;app&quot;);
}
</code></pre><h2 id="dispatching-async-actions">Dispatching Async Actions</h2>
<pre><code class="lang-csharp">// Counter.razor
@page &quot;/counter&quot;
@addTagHelper *, Blazor.Realm
@using Blazor.Realm;

&lt;RealmStateContainer TState=&quot;AppState&quot; Context=&quot;store&quot;&gt;
    &lt;ComponentTemplate&gt;
        @{
            AppState State = store.GetState();
            Action&lt;IRealmAction&gt; Dispatch = store.Dispatch;

            Action IncrementCountAsync = () =&gt; Dispatch(new AsyncIncrementCounter(store, ChangeAmount));
            Action DecrementCount = () =&gt; Dispatch(new DecrementByValue(ChangeAmount));
        }
        &lt;h1&gt;Counter&lt;/h1&gt;

        &lt;p&gt;Current count: @State.Count&lt;/p&gt;

        Change By: &lt;input type=&quot;text&quot; name=&quot;IncementAmount&quot; bind=&quot;@ChangeAmount&quot; /&gt;&lt;br /&gt;

        &lt;button class=&quot;btn btn-primary&quot; onclick=&quot;@IncrementCountAsync&quot;&gt;Increment Async&lt;/button&gt;&lt;br /&gt;
        &lt;button class=&quot;btn btn-primary&quot; onclick=&quot;@DecrementCount&quot;&gt;Decrement&lt;/button&gt;&lt;br /&gt;
    &lt;/ComponentTemplate&gt;
&lt;/RealmStateContainer&gt;

@functions {
    private int ChangeAmount { get; set; } = 1;
}
</code></pre><h1 id="redux-dev-tools">Redux Dev Tools</h1>
<p><img src="../images/redux-devtools.GIF" alt="Redux DevTools"></p>
<p>Connecting to <a href="http://extension.remotedev.io/">Redux DevTools</a> is handled by middleware.</p>
<p>Steps for connecting to Redux Dev Tools:</p>
<ol>
<li><a href="http://extension.remotedev.io/#installation">Install the browser extension</a>.</li>
<li>Install the middleware, <a href="https://www.nuget.org/packages/Blazor.Realm.ReduxDevTools/">https://www.nuget.org/packages/Blazor.Realm.ReduxDevTools/</a></li>
</ol>
<blockquote><p><strong>NOTE</strong></p>
<p>The Redux DevTools middleware does not currently support <a href="https://docs.microsoft.com/en-us/aspnet/core/blazor/hosting-models?view=aspnetcore-3.1#blazor-server">Blazor Server</a>. Work is being done to support integrating with Redux DevTools from a Blazor Server project.</p>
</blockquote>
<h2 id="register-devtools-middleware">Register DevTools Middleware</h2>
<pre><code class="lang-csharp">// Startup.cs
public void Configure(IBlazorApplicationBuilder app,
    IStoreBuilder&lt;AppState&gt; RealmStoreBuilder)
{
    RealmStoreBuilder.UseRealmAsync&lt;AppState&gt;();

    RealmStoreBuilder.UseRealmReduxDevTools&lt;AppState&gt;();

    app.AddComponent&lt;App&gt;(&quot;app&quot;);
}
</code></pre><blockquote><p><strong>NOTE</strong></p>
<p>The order in which middleware is registred matters. Add <code>UseRealmReduxDevTools</code> after <code>UseRealmAsync</code>.</p>
</blockquote>
<h2 id="ignoring-specific-actions">Ignoring Specific Actions</h2>
<pre><code class="lang-csharp">// Startup.cs
public void Configure(IBlazorApplicationBuilder app,
    IStoreBuilder&lt;AppState&gt; RealmStoreBuilder)
{
    RealmStoreBuilder.UseRealmAsync&lt;AppState&gt;();

    RealmStoreBuilder.UseRealmReduxDevTools&lt;AppState&gt;(new System.Type[]
    {
        typeof(Actions.Counter.Dispose)
    });

    app.AddComponent&lt;App&gt;(&quot;app&quot;);
}
</code></pre></article>
          </div>
          
          <div class="hidden-sm col-md-2" role="complementary">
            <div class="sideaffix">
              <div class="contribution">
                <ul class="nav">
                  <li>
                    <a href="https://github.com/dworthen/BlazorRealm/blob/master/docs/quickstart.md/#L1" class="contribution-link">Improve this Doc</a>
                  </li>
                </ul>
              </div>
              <nav class="bs-docs-sidebar hidden-print hidden-xs hidden-sm affix" id="affix">
              <!-- <p><a class="back-to-top" href="#top">Back to top</a><p> -->
              </nav>
            </div>
          </div>
        </div>
      </div>
      
      <footer>
        <div class="grad-bottom"></div>
        <div class="footer">
          <div class="container">
            <span class="pull-right">
              <a href="#top">Back to top</a>
            </span>
            
            <span>Generated by <strong>DocFX</strong></span>
          </div>
        </div>
      </footer>
    </div>
    
    <script type="text/javascript" src="../styles/docfx.vendor.js"></script>
    <script type="text/javascript" src="../styles/docfx.js"></script> {{!--
    <script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/monaco-editor/0.13.1/min/vs/loader.js"></script>
    <script>
      require.config({ paths: { 'vs': 'https://cdnjs.cloudflare.com/ajax/libs/monaco-editor/0.13.1/min/vs' } });
    
      // Before loading vs/editor/editor.main, define a global MonacoEnvironment that overwrites
      // the default worker url location (used when creating WebWorkers). The problem here is that
      // HTML5 does not allow cross-domain web workers, so we need to proxy the instantiation of
      // a web worker through a same-domain script
      window.MonacoEnvironment = {
        getWorkerUrl: function (workerId, label) {
          return `data:text/javascript;charset=utf-8,${encodeURIComponent(`
            self.MonacoEnvironment = {
              baseUrl: 'https://cdnjs.cloudflare.com/ajax/libs/monaco-editor/0.13.1/min/vs'
            };
            importScripts('https://cdnjs.cloudflare.com/ajax/libs/monaco-editor/0.13.1/min/vs/base/worker/workerMain.js');`
          )}`;
        }
      };
    
    
    </script> --}}
    <script type="text/javascript" src="../styles/main.js"></script>  </body>
</html>
